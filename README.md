# -


std::vector<int> container{1, 2, 3, 4};
container.insert(container.begin(), 4);

std::vector::insert используется для вставки одного или нескольких элементов в указанную позицию


В перегрузке функций с++ должны быть разные параметры и одинаковое имя, тип возвращаемого значения тот же


 Где можно объявить/определить новый класс?
В глобальной области видимости
Внутри других классов
Внутри конструкции блок {}


var a *float64
В Go все переменные, объявленные без явной инициализации, получают нулевое значение (zero value) для своего типа.
Для указателей нулевое значение — это nil.


std::unordered_set — это контейнер, который хранит уникальные элементы в порядке, зависящем от хэш-функции.



В Go сигнатура функции — это описание функции, которое включает её имя, параметры и возвращаемые значения. Сигнатура определяет, как функция может быть вызвана и какие данные она принимает и возвращает.
Пример функции с несколькими возвращаемыми значениями:
go
Copy
func maxmin(a, b float64) (max float64, min float64)
Имя функции: maxmin.
Параметры: a, b float64 (два параметра типа float64).
Возвращаемые значения: max float64, min float64 (два значения типа float64).


Ключевое слово mutable в C++ используется для того, чтобы разрешить изменение члена класса (поля) даже в константных методах или у константных объектов



Для enum class не определены арифметические операции (например, +)


В языке Go нет неявного преобразования чисел в логический тип (bool)


В Go поддерживается только оператор for


указатель указывает на адрес &, и там тот же тип данных то это корректное присваивание с++


Анонимная структура — это структура, которая не имеет имени (С++)


В Go горутины (goroutines) запускаются с помощью ключевого слова go, за которым следует вызов функции. Например:
go funcName()
Это создаёт новую горутину, которая выполняет функцию funcName асинхронно.


Горутина (goroutine) в Go — это легковесный поток выполнения, который управляется runtime Go. Горутины позволяют выполнять код асинхронно и параллельно



В Go видимость полей структуры (и других идентификаторов) определяется регистром первой буквы их имени:
Если имя поля начинается с заглавной буквы (например, Title, Description, Price), оно экспортируется (доступно из других пакетов).
Если имя поля начинается с строчной буквы (например, author, pages), оно не экспортируется (недоступно из других пакетов).




std::map<int, int> container;
Создаётся пустой ассоциативный контейнер (словарь) с ключами типа int и значениями типа int.


std::map<int, int> container{{1, 2}, {3, 2}};
container[-1] = 5;
Выражение container[-1] = 5 добавляет новую пару -1: 5 в контейнер.


Таким образом, (1, 2, 3) эквивалентно 3


if (a < b);
else;
пустой if else из-за ";"


В Go нельзя объявить константные поля внутри структуры. Константы объявляются только на уровне пакета



Куча (heap) — это область динамической памяти, которая используется для выделения памяти во время выполнения программы. В отличие от стека (stack), где память выделяется и освобождается автоматически для локальных переменных, куча позволяет управлять памятью вручную.


В C++ нельзя напрямую преобразовать указатель на один тип в указатель на другой тип, если эти типы не связаны через наследование или не являются совместимыми.



Метка OUTER используется для указания, куда должен перейти оператор continue.
Когда выполняется continue OUTER, управление передается на следующую итерацию внешнего цикла for i.



конструктора по умолчанию для класса SomeClass?
SomeClass() = default;
SomeClass(){}




В Go нет ключевых слов-квалификаторов доступа


Ссылки в C++:
Ссылка — это псевдоним для существующей переменной. Она должна быть инициализирована при объявлении и не может быть изменена для ссылки на другой объект.
Синтаксис: тип& имя = инициализатор;.



Обе функции имеют одинаковое имя и принимают параметр типа int. Различие только в том, что одна функция принимает параметр как const int, а другая — как int.
В C++ такие функции считаются неоднозначными, так как компилятор не может определить, какую из них вызвать, если передаётся обычная переменная int


в C++ перегруженные операторы должны возвращать значение
